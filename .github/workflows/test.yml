name: ðŸ—ï¸ Build the Application

on:
  workflow_call:
    inputs:
      pnpm-cache-key:
        description: "The generated pnpm cache key"
        required: true
        type: string
      node-version:
        description: "Node.js version"
        required: false
        default: "22"
        type: string
      pnpm-version:
        description: "pnpm version"
        required: false
        default: "10.6.4"
        type: string
      run-affected:
        description: "Run affected commands"
        required: false
        default: true
        type: boolean
      upload-coverage:
        description: "Upload coverage to Codecov"
        required: false
        default: true
        type: boolean
    secrets:
      NX_CLOUD_ACCESS_TOKEN:
        description: "Nx Cloud access token"
        required: true
    outputs:
      coverage-artifact-key:
        description: "Coverage artifact key"
        value: ${{ jobs.upload.outputs.coverage-artifact-key }}

jobs:
  test:
    name:  ðŸ§ªTest
    runs-on: ubuntu-latest
    env:
      NX_CLOUD_ACCESS_TOKEN: ${{ secrets.NX_CLOUD_ACCESS_TOKEN }}
    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ðŸ§® Calculate Nx Base and Head
        if: ${{ inputs.run-affected == true }}
        uses: nrwl/nx-set-shas@v4
        with:
          main-branch-name: 'main'

      - name: ðŸ“¦ Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ inputs.pnpm-version }}

      - name: ðŸŸ¢ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node-version }}
          cache: 'pnpm'

      - name: ðŸ“š Restore dependency cache
        id: cache-deps
        uses: actions/cache@v4
        with:
          path: |
            node_modules
            */*/node_modules
          key: ${{ inputs.pnpm-cache-key }}

      - name: ðŸ“¥ Install dependencies
        if: steps.cache-deps.outputs.cache-hit != 'true'
        run: |
          echo "ðŸ”„ Cache miss - Installing dependencies..."
          pnpm install --frozen-lockfile
          echo "âœ… Dependencies installed successfully"     

      # Run tests with the SHAs set by nx-set-shas
      - name: ðŸ§ª Run affected tests
        if: ${{ inputs.run-affected == true }}
        run: |
          echo "ðŸ” Running tests on affected projects..."
          echo "Using base: $NX_BASE"
          echo "Using head: $NX_HEAD"

          pnpm nx affected --target=test
          echo "âœ… Tests completed successfully"

      # Runs all tests
      - name: ðŸ§ª Run all tests
        if: ${{ inputs.run-affected == false }}
        run: |
          echo "run-affected: ${{ inputs.run-affected }}"
          echo "ðŸ” Running tests on all projects..."
          
          pnpm nx run-many --target=test --parallel=3
          echo "âœ… Tests completed successfully"    

      - name: ðŸ“Š Test Summary
        if: always()
        run: |
          echo "## ðŸ§ª Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ ${{ job.status }} == 'success' ]; then
            echo "âœ… All tests passed!" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ Some tests failed" >> $GITHUB_STEP_SUMMARY
          fi

      - name: ðŸ” Verify main branch
        if: ${{ inputs.upload-coverage == true }}
        id: verify-branch
        run: |
          CURRENT_BRANCH=$(git branch --show-current || git symbolic-ref --short HEAD || echo ${GITHUB_REF#refs/heads/})
          echo "Current branch: $CURRENT_BRANCH"

          if [[ "$CURRENT_BRANCH" != "main" && "${GITHUB_REF#refs/heads/}" != "main" ]]; then
            echo "âŒ Code coverage should only be uploaded from the main branch. Current branch: $CURRENT_BRANCH"
            exit 1
          fi

          echo "âœ… Running on main branch."

      - name: ðŸ”„ Merge package coverage reports
        if: ${{ inputs.upload-coverage == true }}
        id: merge-coverage
        run: |
          echo "ðŸ” Locating coverage reports in packages directory..."

          # Create directory for combined coverage
          mkdir -p combined-coverage

          # Find all lcov.info files in the packages directory
          LCOV_COUNT=$(find ./packages -type f -name 'lcov.info' -path '*/coverage/lcov.info' | wc -l)
          echo "Found $LCOV_COUNT lcov.info files in packages"

          if [ $LCOV_COUNT -eq 0 ]; then
            echo "::error::No lcov.info files found in packages directory. Tests may not have generated coverage reports."
            exit 1
          fi

          # Merge all the lcov.info files into one
          find ./packages -type f -name 'lcov.info' -path '*/coverage/lcov.info' -exec cat {} + > ./combined-coverage/lcov.info

          # Check if merged file has content
          MERGED_SIZE=$(wc -c < ./combined-coverage/lcov.info)
          if [ ! -s ./combined-coverage/lcov.info ] || [ $MERGED_SIZE -eq 0 ]; then
            echo "::error::Merged coverage file is empty"
            exit 1
          fi

          echo "âœ… Successfully merged $LCOV_COUNT package coverage files ($(du -h ./combined-coverage/lcov.info | cut -f1) total)"
          echo "lcov_count=$LCOV_COUNT" >> $GITHUB_OUTPUT
          echo "merged_size=$MERGED_SIZE" >> $GITHUB_OUTPUT

      # Get git info for artifact naming
      - name: ðŸ“‹ Get Git info
        if: ${{ inputs.upload-coverage == true }}
        id: git-info
        run: |
          COMMIT_HASH=$(git rev-parse --short HEAD)
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          echo "commit_hash=$COMMIT_HASH" >> $GITHUB_OUTPUT
          echo "timestamp=$TIMESTAMP" >> $GITHUB_OUTPUT
          echo "Commit hash: $COMMIT_HASH"
          echo "Timestamp: $TIMESTAMP"

      # Package coverage for release artifacts
      - name: ðŸ“¦ Package coverage reports
        if: ${{ inputs.upload-coverage == true }}
        id: package-coverage
        run: |
          # Use commit hash and timestamp for artifact naming
          COMMIT_HASH="${{ steps.git-info.outputs.commit_hash }}"
          TIMESTAMP="${{ steps.git-info.outputs.timestamp }}"
          ARTIFACT_NAME="coverage-report-${COMMIT_HASH}-${TIMESTAMP}"

          # Create directory for artifacts
          mkdir -p coverage-artifacts
          cp ./combined-coverage/lcov.info coverage-artifacts/lcov.info

          # Try to generate HTML report if tools available
          if command -v genhtml >/dev/null 2>&1; then
            echo "ðŸ“Š Generating HTML coverage report..."
            genhtml ./combined-coverage/lcov.info -o coverage-artifacts/html --title "Coverage Report ${COMMIT_HASH}"
            echo "âœ… HTML coverage report generated"
          else
            mkdir -p coverage-artifacts/html
            echo "<html><body><h1>Coverage Report ${COMMIT_HASH}</h1><p>HTML report unavailable. See lcov.info for raw data.</p></body></html>" > coverage-artifacts/html/index.html
            echo "â„¹ï¸ lcov tools not available, created placeholder HTML"
          fi

          # Create a summary file with repo info
          {
            echo "# Coverage Report"
            echo ""
            echo "## Repository Information"
            echo "- **Commit:** ${COMMIT_HASH}"
            echo "- **Branch:** main"
            echo "- **Date:** $(date)"
            echo ""
            echo "## Coverage Summary"
            echo "- **Packages covered:** ${{ steps.merge-coverage.outputs.lcov_count }}"
            echo "- **Report size:** $(du -h ./combined-coverage/lcov.info | cut -f1)"
            echo ""

            # List the packages that were covered (up to 20)
            echo "## Packages"
            find ./packages -type f -name 'lcov.info' -path '*/coverage/lcov.info' | sort | head -n 20 | while read file; do
              # Extract package name from path
              PACKAGE_PATH=$(dirname $(dirname "$file"))
              PACKAGE_NAME=$(basename "$PACKAGE_PATH")
              echo "- $PACKAGE_NAME"
            done

            if [ ${{ steps.merge-coverage.outputs.lcov_count }} -gt 20 ]; then
              echo "- ... and $(({{ steps.merge-coverage.outputs.lcov_count }} - 20)) more"
            fi
          } > coverage-artifacts/COVERAGE.md

          echo "artifact-name=${ARTIFACT_NAME}" >> $GITHUB_OUTPUT
          echo "âœ… Coverage artifacts prepared"

      # Upload to Codecov
      - name: ðŸ“¤ Upload to Codecov
        if: ${{ inputs.upload-coverage == true }}
        uses: codecov/codecov-action@v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./combined-coverage/lcov.info
          flags: production,release
          name: ${{ steps.git-info.outputs.commit_hash }}
          fail_ci_if_error: true
          verbose: true

      # Upload coverage artifacts for releases
      - name: ðŸ“¤ Upload coverage artifact for release
        if: ${{ inputs.upload-coverage == true }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.package-coverage.outputs.artifact-name }}
          path: coverage-artifacts/
          retention-days: 90

      # Create a summary for GitHub Actions
      - name: ðŸ“Š Coverage Summary
        if: ${{ inputs.upload-coverage == true }}
        run: |
          {
            echo "## ðŸ“Š Coverage Report Summary"
            echo ""
            echo "âœ… Successfully processed ${{ steps.merge-coverage.outputs.lcov_count }} package coverage files"
            echo ""
            echo "### ðŸ“¦ Artifacts"
            echo "- **Artifact Name:** \`${{ steps.package-coverage.outputs.artifact-name }}\`"
            echo "- **Coverage Size:** $(du -h ./combined-coverage/lcov.info | cut -f1)"
            echo "- **Commit:** ${{ steps.git-info.outputs.commit_hash }}"
            echo ""
            echo "This report has been uploaded to Codecov and is available as a downloadable artifact."
          } >> $GITHUB_STEP_SUMMARY